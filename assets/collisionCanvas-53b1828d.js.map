{"version":3,"file":"collisionCanvas-53b1828d.js","sources":["../src/messaging/setupMessageChannel.ts","../src/messaging/webWorkerMessageChannel.ts","../src/utility.ts","../src/messaging/valueConverters.ts","../src/collisionCanvas/collisionCanvasMessaging.ts","../src/collisionCanvas/collisionCanvas.tsx"],"sourcesContent":["/**\n * While this looks a bit jacked, it is just pubsub bindable to arbitrary string event interface using typed, custom, serializing.\n * Used by RTCDataChannel connections and webworkers. Data format is \"MESSAGE_TYPE;MESSAGE_DATA_WITH_CONFIGURED_SERIALIZER\"\n * Why not use JSON like a normal person?\n * Earlier i just put everything from UDP/Worker-messaging into JSON, but the 1ms added here and there actually adds upp to quite a bit of CPU time\n * A lot of events (turns/pings) don't have associated data, parsing json just to read a \"type\" prop of result.\n * Looked into protobufs but it looked very cargo-culty to me and not really established in JS-land.\n */\n\nexport type Converter<TResult> = {\n  serialize(result: TResult): string | void;\n  deserialize(input?: string): TResult;\n};\n\nexport type ConverterCollection = Record<string, Converter<any>>;\n\ntype EventHooks<TExtraSendParams extends any[] = []> = {\n  send(input: string, ...params: TExtraSendParams): void;\n  bindReceive(receive: (input: string) => void): (() => void) | void;\n};\n\ntype ConverterType<TConverter extends Converter<any>> =\n  TConverter extends Converter<infer Result> ? Result : never;\n\nexport type MessageChannel<\n  TSend extends ConverterCollection,\n  TReceive extends ConverterCollection,\n  TExtraSendParams extends any[] = []\n> = {\n  send<TMessage extends Extract<keyof TSend, string>>(\n    type: TMessage,\n    data: ConverterType<TSend[TMessage]>,\n    ...extraParams: TExtraSendParams\n  ): void;\n  on<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  off<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  destroy(): void;\n};\n\nexport type BindableMessageChannel = ReturnType<typeof setupMessageChannel>;\n\n//HoF just to cut down on TS generic bloat.\nexport default function setupMessageChannel<\n  TExtraSendParams extends any[] = []\n>(channelHooks: EventHooks<TExtraSendParams>) {\n  return <\n    TSend extends ConverterCollection,\n    TReceive extends ConverterCollection\n  >(\n    send: TSend,\n    receive: TReceive,\n    ...bounce: string[]\n  ): MessageChannel<TSend, TReceive, TExtraSendParams> => {\n    const bounceSet = new Set(bounce);\n    const listeners = new Map<keyof TReceive, Function[]>();\n    //bind a single event listener to \"outer event\" and filter on serialized message type.\n    const unbind = channelHooks.bindReceive((input) => {\n      if (typeof input !== \"string\") {\n        return;\n      }\n      const indexOfMessageSeparator = input.indexOf(\";\");\n      const messageType =\n        indexOfMessageSeparator && input.substring(0, indexOfMessageSeparator);\n      //No message type could be parsed, exit out\n      if (!messageType) {\n        return;\n      }\n      //if this is a configured bounce message, bounce it directly as it came.\n      if (bounceSet.has(messageType)) {\n        //@ts-ignore no params here\n        channelHooks.send(input);\n      }\n      //check if anyones is listening before parsing message data and invoking listeners.\n      const messageListeners = listeners.get(messageType);\n      if (messageListeners?.length) {\n        const messageData = receive[messageType]?.deserialize(\n          input.substring(indexOfMessageSeparator + 1)\n        );\n        messageListeners.forEach((listener) => listener(messageData));\n      }\n    });\n    return {\n      send(type, data, ...extraParams) {\n        const message = `${type};${send[type].serialize(data)}`;\n        channelHooks.send(message, ...extraParams);\n      },\n      on(type, fn) {\n        if (!listeners.has(type)) {\n          listeners.set(type, []);\n        }\n        listeners.get(type)?.push(fn);\n      },\n      off(type, fn) {\n        const fnIndex = listeners.get(type)?.indexOf(fn);\n        if (fnIndex != null && fnIndex != -1) {\n          listeners.get(type)?.splice(fnIndex, 1);\n        }\n      },\n      destroy: unbind ? unbind : () => {},\n    };\n  };\n}\n\n/**Create a passthrough bridge between two sets of channelhooks */\nexport function bridgeChannelHooks(\n  channelHooks1: EventHooks,\n  channelHooks2: EventHooks\n) {\n  const unbind1 = channelHooks1.bindReceive(channelHooks2.send);\n  const unbind2 = channelHooks2.bindReceive(channelHooks1.send);\n  return {\n    destroy() {\n      unbind1 && unbind1();\n      unbind2 && unbind2();\n    },\n  };\n}\n","import setupMessageChannel, {\n  ConverterCollection,\n} from \"./setupMessageChannel\";\n\nexport function createWebWorkerMessageChannel(\n  worker: Worker | DedicatedWorkerGlobalScope\n) {\n  return <\n    SendMessages extends ConverterCollection,\n    ReceiveMessages extends ConverterCollection\n  >(\n    sends: SendMessages,\n    recieves: ReceiveMessages\n  ) =>\n    setupMessageChannel({\n      send: worker.postMessage.bind(worker),\n      bindReceive(receive) {\n        const listener = (ev: any) => receive(ev.data);\n        worker.addEventListener(\"message\", listener);\n        return () => worker.removeEventListener(\"message\", listener)\n      },\n    })(sends, recieves);\n}\n","export const typedEntries = Object.entries as <T, TKey extends keyof T>(\n  o: T\n) => [Extract<TKey, string>, T[TKey]][];\n\nexport const typedKeys = Object.keys as <T>(o: T) => (keyof T)[];\n\nexport function extractObjectDiff<T>(\n  source: T,\n  update: T,\n  ...omitTypes: string[]\n): Partial<T> {\n  return typedEntries(update ?? {})\n    .filter((entry) => !omitTypes.includes(typeof entry[1]))\n    .reduce((acc, [key, value]) => {\n      if (source?.[key] !== value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {} as Partial<T>);\n}\n\nexport function inlineThrow(err: string | Error): never {\n  throw typeof err === \"string\" ? new Error(err) : err;\n}\n\n//https://gist.github.com/LeverOne/1308368\nexport function uuidV4() {\n  let result = \"\";\n  for (\n    let step = 0;\n    step++ < 36;\n    result +=\n      (step * 51) & 52\n        ? (step ^ 15 ? 8 ^ (Math.random() * (step ^ 20 ? 16 : 4)) : 4).toString(\n            16\n          )\n        : \"-\"\n  );\n  return result;\n}\n\nexport function match<TMatch extends keyof any, TResult>(\n  value: TMatch,\n  output: Record<TMatch, TResult>\n){\n  return output[value];\n}\n","import { Converter } from \"./setupMessageChannel\";\n\nexport const jsonConverter: Converter<any> = {\n  serialize: JSON.stringify,\n  deserialize: JSON.parse\n};\n\nexport const numberConverter: Converter<number> = {\n  serialize: String,\n  deserialize: Number\n};\n\nexport const booleanConverter: Converter<boolean> = {\n  serialize: String,\n  deserialize: Boolean\n};\n\n//This should not be needed, but having a special case for no message conversion will make channel impl. even messier.\n//Bench before changing\nexport const passValueConverter = <T extends string | void>(): Converter<T> => ({\n  serialize: input => input,\n  deserialize: result => result as T\n});\n\nexport const stringConverter = passValueConverter<string>();\n\nexport const voidConverter = passValueConverter<void>();","import { Converter, MessageChannel } from \"../messaging/setupMessageChannel\";\nimport { jsonConverter, stringConverter } from \"../messaging/valueConverters\";\n\nexport const messagesToTracker = {\n  canvasInfo: jsonConverter as Converter<{\n    width: number;\n    height: number;\n    scaleFactor: number;\n    lineWidth: number;\n  }>,\n  positionData: jsonConverter as Converter<\n    { id: string; x: number; y: number; fill?: string }[]\n  >,\n};\nexport const messagesFromTracker = {\n  reportCollision: stringConverter,\n};\n\nexport type TrackerMessageChannel = MessageChannel<\n  typeof messagesToTracker,\n  typeof messagesFromTracker\n>;\n","/// <reference lib=\"WebWorker\" />\nimport { BindableMessageChannel } from \"../messaging/setupMessageChannel\";\nimport { createWebWorkerMessageChannel } from \"../messaging/webWorkerMessageChannel\";\nimport { inlineThrow } from \"../utility\";\nimport {\n  messagesFromTracker,\n  messagesToTracker,\n} from \"./collisionCanvasMessaging\";\n\ntype Point = { x: number; y: number };\n\nfunction createTrackerCanvas(\n  canvas: HTMLCanvasElement | OffscreenCanvas,\n  channelCreator: BindableMessageChannel,\n  checkCollisions: boolean\n) {\n  const channel = channelCreator(messagesFromTracker, messagesToTracker);\n  const context =\n    canvas.getContext(\"2d\") ??\n    inlineThrow(\"Could not get context of tracker canvas\");\n  let lineWidth = 0;\n  channel.on(\"canvasInfo\", (info) => {\n    canvas.height = info.height;\n    canvas.width = info.width;\n    context.scale(info.scaleFactor, info.scaleFactor);\n    lineWidth = info.lineWidth;\n  });\n  const prevPositions: Record<string, Point> = {};\n  channel.on(\"positionData\", (data) => {\n    data.forEach((pos) => {\n      const prevPos = prevPositions[pos.id];\n      prevPositions[pos.id] = { x: pos.x, y: pos.y };\n      const futurePos =\n        prevPos != null &&\n        !(prevPos.x === pos.x && prevPos.y === pos.y) &&\n        getUpcomingPosition(prevPos, pos);\n      if (\n        checkCollisions &&\n        (pos.x < 0 ||\n          pos.x > canvas.width ||\n          pos.y < 0 ||\n          pos.y > canvas.height ||\n          (futurePos &&\n            context.getImageData(futurePos.x, futurePos.y, 1, 1).data[3] !== 0))\n      ) {\n        //Position is collision\n        channel.send(\"reportCollision\", pos.id);\n      }\n      if (!pos.fill || prevPos == null) {\n        return;\n      }\n      //Draw new position\n      context.beginPath();\n      context.lineCap = \"square\";\n      context.lineWidth = lineWidth;\n      context.strokeStyle = pos.fill;\n      context.moveTo(prevPos.x, prevPos.y);\n      context.lineTo(pos.x, pos.y);\n      context.stroke();\n      context.closePath();\n      prevPos.x = pos.x;\n      prevPos.y = pos.y;\n    });\n  });\n}\n\nconst getUpcomingPosition = (prevPos: Point, currentPos: Point) => {\n  const length = Math.sqrt(\n    Math.pow(prevPos.x - currentPos.x, 2) +\n      Math.pow(prevPos.y - currentPos.y, 2)\n  );\n  return {\n    x: currentPos.x + ((currentPos.x - prevPos.x) / length) * 3,\n    y: currentPos.y + ((currentPos.y - prevPos.y) / length) * 3,\n  };\n};\n\nself.addEventListener(\n  \"message\",\n  function initialMessageHandler(ev: MessageEvent) {\n    const canvas =\n      ev.data instanceof OffscreenCanvas\n        ? ev.data\n        : ev.data === \"SELF_HOST_CANVAS\"\n        ? new OffscreenCanvas(0, 0)\n        : inlineThrow(\n            'Either transfer a OffScreenCanvas to worker or send string \"SELF_HOSTED_CANVAS\" as initial message to worker'\n          );\n    self.removeEventListener(\"message\", initialMessageHandler);\n    createTrackerCanvas(\n      canvas,\n      createWebWorkerMessageChannel(self as DedicatedWorkerGlobalScope),\n      true\n    );\n  }\n);\n"],"names":["setupMessageChannel","channelHooks","send","receive","bounce","bounceSet","listeners","unbind","input","indexOfMessageSeparator","messageType","messageListeners","messageData","_a","listener","type","data","extraParams","message","fn","fnIndex","_b","createWebWorkerMessageChannel","worker","sends","recieves","ev","inlineThrow","err","jsonConverter","stringConverter","result","messagesToTracker","messagesFromTracker","createTrackerCanvas","canvas","channelCreator","checkCollisions","channel","context","lineWidth","info","prevPositions","pos","prevPos","futurePos","getUpcomingPosition","currentPos","length","initialMessageHandler"],"mappings":"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"}