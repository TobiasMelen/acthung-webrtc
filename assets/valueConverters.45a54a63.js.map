{"version":3,"file":"valueConverters.45a54a63.js","sources":["../../src/messaging/setupMessageChannel.ts","../../src/messaging/valueConverters.ts"],"sourcesContent":["/**\n * While this looks a bit jacked, it is just pubsub bindable to arbitrary string event interface using typed, custom, serializing.\n * Used by RTCDataChannel connections and webworkers. Data format is \"MESSAGE_TYPE;MESSAGE_DATA_WITH_CONFIGURED_SERIALIZER\"\n * Why not use JSON like a normal person?\n * Earlier i just put everything from UDP/Worker-messaging into JSON, but the 1ms added here and there actually adds upp to quite a bit of CPU time\n * A lot of events (turns/pings) don't have associated data, parsing json just to read a \"type\" prop of result.\n * Looked into protobufs but it looked very cargo-culty to me and not really established in JS-land.\n */\n\nexport type Converter<TResult> = {\n  serialize(result: TResult): string | void;\n  deserialize(input?: string): TResult;\n};\n\nexport type ConverterCollection = Record<string, Converter<any>>;\n\ntype EventHooks<TExtraSendParams extends any[] = []> = {\n  send(input: string, ...params: TExtraSendParams): void;\n  bindReceive(receive: (input: string) => void): (() => void) | void;\n};\n\ntype ConverterType<\n  TConverter extends Converter<any>\n> = TConverter extends Converter<infer Result> ? Result : never;\n\nexport type MessageChannel<\n  TSend extends ConverterCollection,\n  TReceive extends ConverterCollection,\n  TExtraSendParams extends any[] = []\n> = {\n  send<TMessage extends keyof TSend>(\n    type: TMessage,\n    data: ConverterType<TSend[TMessage]>,\n    ...extraParams: TExtraSendParams\n  ): void;\n  on<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  off<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  destroy(): void;\n};\n\nexport type BindableMessageChannel = ReturnType<typeof setupMessageChannel>;\n\n//HoF just to cut down on TS generic bloat.\nexport default function setupMessageChannel<\n  TExtraSendParams extends any[] = []\n>(channelHooks: EventHooks<TExtraSendParams>) {\n  return <\n    TSend extends ConverterCollection,\n    TReceive extends ConverterCollection\n  >(\n    send: TSend,\n    receive: TReceive,\n    ...bounce: string[]\n  ): MessageChannel<TSend, TReceive, TExtraSendParams> => {\n    const bounceSet = new Set(bounce);\n    const listeners = new Map<keyof TReceive, Function[]>();\n    //bind a single event listener to \"outer event\" and filter on serialized message type.\n    const unbind = channelHooks.bindReceive((input) => {\n      if (typeof input !== \"string\") {\n        return;\n      }\n      const indexOfMessageSeparator = input.indexOf(\";\");\n      const messageType =\n        indexOfMessageSeparator && input.substring(0, indexOfMessageSeparator);\n      //No message type could be parsed, exit out\n      if (!messageType) {\n        return;\n      }\n      //if this is a configured bounce message, bounce it directly as it came.\n      if (bounceSet.has(messageType)) {\n        //@ts-ignore no params here\n        channelHooks.send(input);\n      }\n      //check if anyones is listening before parsing message data and invoking listeners.\n      const messageListeners = listeners.get(messageType);\n      if (messageListeners?.length) {\n        const messageData = receive[messageType]?.deserialize(\n          input.substring(indexOfMessageSeparator + 1)\n        );\n        messageListeners.forEach((listener) => listener(messageData));\n      }\n    });\n    return {\n      send(type, data, ...extraParams) {\n        const message = `${type};${send[type].serialize(data)}`;\n        channelHooks.send(message, ...extraParams);\n      },\n      on(type, fn) {\n        if (!listeners.has(type)) {\n          listeners.set(type, []);\n        }\n        listeners.get(type)?.push(fn);\n      },\n      off(type, fn) {\n        const fnIndex = listeners.get(type)?.indexOf(fn);\n        if (fnIndex != null && fnIndex != -1) {\n          listeners.get(type)?.splice(fnIndex, 1);\n        }\n      },\n      destroy: unbind ? unbind : () => {},\n    };\n  };\n}\n\n/**Create a passthrough bridge between two sets of channelhooks */\nexport function bridgeChannelHooks(\n  channelHooks1: EventHooks,\n  channelHooks2: EventHooks\n) {\n  const unbind1 = channelHooks1.bindReceive(channelHooks2.send);\n  const unbind2 = channelHooks2.bindReceive(channelHooks1.send);\n  return {\n    destroy() {\n      unbind1 && unbind1();\n      unbind2 && unbind2();\n    },\n  };\n}\n","import { Converter } from \"./setupMessageChannel\";\n\nexport const jsonConverter: Converter<any> = {\n  serialize: JSON.stringify,\n  deserialize: JSON.parse\n};\n\nexport const numberConverter: Converter<number> = {\n  serialize: String,\n  deserialize: Number\n};\n\nexport const booleanConverter: Converter<boolean> = {\n  serialize: String,\n  deserialize: Boolean\n};\n\n//This should not be needed, but having a special case for no message conversion will make channel impl. even messier.\n//Bench before changing\nconst passValueConverter = <T extends string | void>(): Converter<T> => ({\n  serialize: input => input,\n  deserialize: result => result as T\n});\n\nexport const stringConverter = passValueConverter<string>();\n\nexport const voidConverter = passValueConverter<void>();"],"names":["channelHooks","send","receive","bounce","bounceSet","Set","listeners","Map","unbind","bindReceive","input","indexOfMessageSeparator","indexOf","messageType","substring","has","messageListeners","get","length","messageData","deserialize","forEach","listener","[object Object]","type","data","extraParams","message","serialize","fn","set","push","fnIndex","splice","destroy","jsonConverter","JSON","stringify","parse","numberConverter","String","Number","booleanConverter","Boolean","stringConverter","result"],"mappings":"WAmDEA,SACO,CAILC,EACAC,KACGC,WAEGC,EAAY,IAAIC,IAAIF,GACpBG,EAAY,IAAIC,IAEhBC,EAASR,EAAaS,aAAaC,aAClB,iBAAVA,eAGLC,EAA0BD,EAAME,QAAQ,KACxCC,EACJF,GAA2BD,EAAMI,UAAU,EAAGH,OAE3CE,SAIDT,EAAUW,IAAIF,MAEHZ,KAAKS,SAGdM,EAAmBV,EAAUW,IAAIJ,YACnCG,WAAkBE,OAAQ,OACtBC,EAAc,WAAQN,aAAcO,YACxCV,EAAMI,UAAUH,EAA0B,MAE3BU,SAASC,GAAaA,EAASH,eAG7C,CACLI,KAAKC,EAAMC,KAASC,SACZC,EAAU,GAAGH,KAAQvB,EAAKuB,GAAMI,UAAUH,OACnCxB,KAAK0B,KAAYD,IAEhCH,GAAGC,EAAMK,SACFvB,EAAUS,IAAIS,MACPM,IAAIN,EAAM,eAEZP,IAAIO,OAAOO,KAAKF,IAE5BN,IAAIC,EAAMK,iBACFG,EAAU,WAAUf,IAAIO,aAAOZ,QAAQiB,GAC9B,MAAXG,OAAmBA,eACXf,IAAIO,OAAOS,OAAOD,EAAS,KAGzCE,QAAS1B,GAAkB,iBCvGpB2B,EAAgC,CAC3CP,UAAWQ,KAAKC,UAChBjB,YAAagB,KAAKE,OAGPC,EAAqC,CAChDX,UAAWY,OACXpB,YAAaqB,QAGFC,EAAuC,CAClDd,UAAWY,OACXpB,YAAauB,SAUFC,GAJXhB,aAAoBlB,EACpBU,eAAuByB"}