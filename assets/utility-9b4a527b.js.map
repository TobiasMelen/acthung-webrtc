{"version":3,"file":"utility-9b4a527b.js","sources":["../../src/constants.tsx","../../src/messaging/valueConverters.ts","../../src/messaging/setupMessageChannel.ts","../../src/messaging/dataChannelMessaging.ts","../../src/hooks/useJsonWebsocket.ts","../../src/utility.ts"],"sourcesContent":["export const SIGNALING_URL =\n  import.meta.env.VITE_SIGNAL_URL ??\n  (() => {\n    throw new Error(\n      \"VITE_SIGNAL_URL for signaling server must be specified in env.\"\n    );\n  })();\n\nexport const DEFAULT_COLOR = \"white\";\n\nexport const DEFAULT_FONT_FAMILY = `-apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell, \"Open Sans\", \"Helvetica Neue\", sans-serif`;\n\nexport const DEFAULT_FONT_FAMILY_MONOSPACE = `SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, Courier, monospace`;\n\nexport const ALL_COLORS = [\n  \"#3f5\",\n  \"#f24\",\n  \"#46f\",\n  \"#ef2\",\n  \"#d3f\",\n  \"#f9b\",\n  \"#fff\",\n];\n\nexport const DEFAULT_RTC_PEER_CONFIG: RTCConfiguration = {\n  iceServers: [\n    { urls: [\"stun:stun.l.google.com:19302\"] }\n  ],\n};\n","import { Converter } from \"./setupMessageChannel\";\n\nexport const jsonConverter: Converter<any> = {\n  serialize: JSON.stringify,\n  deserialize: JSON.parse\n};\n\nexport const numberConverter: Converter<number> = {\n  serialize: String,\n  deserialize: Number\n};\n\nexport const booleanConverter: Converter<boolean> = {\n  serialize: String,\n  deserialize: Boolean\n};\n\n//This should not be needed, but having a special case for no message conversion will make channel impl. even messier.\n//Bench before changing\nexport const passValueConverter = <T extends string | void>(): Converter<T> => ({\n  serialize: input => input,\n  deserialize: result => result as T\n});\n\nexport const stringConverter = passValueConverter<string>();\n\nexport const voidConverter = passValueConverter<void>();","/**\n * While this looks a bit jacked, it is just pubsub bindable to arbitrary string event interface using typed, custom, serializing.\n * Used by RTCDataChannel connections and webworkers. Data format is \"MESSAGE_TYPE;MESSAGE_DATA_WITH_CONFIGURED_SERIALIZER\"\n * Why not use JSON like a normal person?\n * Earlier i just put everything from UDP/Worker-messaging into JSON, but the 1ms added here and there actually adds upp to quite a bit of CPU time\n * A lot of events (turns/pings) don't have associated data, parsing json just to read a \"type\" prop of result.\n * Looked into protobufs but it looked very cargo-culty to me and not really established in JS-land.\n */\n\nexport type Converter<TResult> = {\n  serialize(result: TResult): string | void;\n  deserialize(input?: string): TResult;\n};\n\nexport type ConverterCollection = Record<string, Converter<any>>;\n\ntype EventHooks<TExtraSendParams extends any[] = []> = {\n  send(input: string, ...params: TExtraSendParams): void;\n  bindReceive(receive: (input: string) => void): (() => void) | void;\n};\n\ntype ConverterType<\n  TConverter extends Converter<any>\n> = TConverter extends Converter<infer Result> ? Result : never;\n\nexport type MessageChannel<\n  TSend extends ConverterCollection,\n  TReceive extends ConverterCollection,\n  TExtraSendParams extends any[] = []\n> = {\n  send<TMessage extends keyof TSend>(\n    type: TMessage,\n    data: ConverterType<TSend[TMessage]>,\n    ...extraParams: TExtraSendParams\n  ): void;\n  on<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  off<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  destroy(): void;\n};\n\nexport type BindableMessageChannel = ReturnType<typeof setupMessageChannel>;\n\n//HoF just to cut down on TS generic bloat.\nexport default function setupMessageChannel<\n  TExtraSendParams extends any[] = []\n>(channelHooks: EventHooks<TExtraSendParams>) {\n  return <\n    TSend extends ConverterCollection,\n    TReceive extends ConverterCollection\n  >(\n    send: TSend,\n    receive: TReceive,\n    ...bounce: string[]\n  ): MessageChannel<TSend, TReceive, TExtraSendParams> => {\n    const bounceSet = new Set(bounce);\n    const listeners = new Map<keyof TReceive, Function[]>();\n    //bind a single event listener to \"outer event\" and filter on serialized message type.\n    const unbind = channelHooks.bindReceive((input) => {\n      if (typeof input !== \"string\") {\n        return;\n      }\n      const indexOfMessageSeparator = input.indexOf(\";\");\n      const messageType =\n        indexOfMessageSeparator && input.substring(0, indexOfMessageSeparator);\n      //No message type could be parsed, exit out\n      if (!messageType) {\n        return;\n      }\n      //if this is a configured bounce message, bounce it directly as it came.\n      if (bounceSet.has(messageType)) {\n        //@ts-ignore no params here\n        channelHooks.send(input);\n      }\n      //check if anyones is listening before parsing message data and invoking listeners.\n      const messageListeners = listeners.get(messageType);\n      if (messageListeners?.length) {\n        const messageData = receive[messageType]?.deserialize(\n          input.substring(indexOfMessageSeparator + 1)\n        );\n        messageListeners.forEach((listener) => listener(messageData));\n      }\n    });\n    return {\n      send(type, data, ...extraParams) {\n        const message = `${type};${send[type].serialize(data)}`;\n        channelHooks.send(message, ...extraParams);\n      },\n      on(type, fn) {\n        if (!listeners.has(type)) {\n          listeners.set(type, []);\n        }\n        listeners.get(type)?.push(fn);\n      },\n      off(type, fn) {\n        const fnIndex = listeners.get(type)?.indexOf(fn);\n        if (fnIndex != null && fnIndex != -1) {\n          listeners.get(type)?.splice(fnIndex, 1);\n        }\n      },\n      destroy: unbind ? unbind : () => {},\n    };\n  };\n}\n\n/**Create a passthrough bridge between two sets of channelhooks */\nexport function bridgeChannelHooks(\n  channelHooks1: EventHooks,\n  channelHooks2: EventHooks\n) {\n  const unbind1 = channelHooks1.bindReceive(channelHooks2.send);\n  const unbind2 = channelHooks2.bindReceive(channelHooks1.send);\n  return {\n    destroy() {\n      unbind1 && unbind1();\n      unbind2 && unbind2();\n    },\n  };\n}\n","import {\n  jsonConverter,\n  stringConverter,\n  booleanConverter,\n  numberConverter,\n} from \"./valueConverters\";\nimport setupMessageChannel, { Converter } from \"./setupMessageChannel\";\n\nconst messagesToPlayer = {\n  playerState: jsonConverter as Converter<Partial<PlayerState>>,\n  gameState: jsonConverter as Converter<Partial<GameState>>,\n  ping: numberConverter,\n  err: jsonConverter,\n};\n\nconst messagesToLobby = {\n  setColor: stringConverter,\n  setReady: booleanConverter,\n  setName: stringConverter,\n  allowSinglePlayer: booleanConverter,\n  turn: numberConverter,\n  ping: numberConverter,\n};\n\nexport type MessageTypesToPlayer = keyof typeof messagesToPlayer;\nexport type MessageTypesToLobby = keyof typeof messagesToLobby;\n\nexport type MessageChannelToPlayer = ReturnType<\n  typeof createMessageChannelToPlayer\n>;\n\nexport function createMessageChannelToPlayer(\n  connection: RTCPeerConnection,\n  dataChannel: RTCDataChannel\n) {\n  return setupMessageDataChannel(connection, dataChannel)(\n    messagesToPlayer,\n    messagesToLobby,\n    \"ping\"\n  );\n}\n\nexport type MessageChannelToLobby = ReturnType<\n  typeof createMessageChannelToLobby\n>;\n\nexport function createMessageChannelToLobby(\n  connection: RTCPeerConnection,\n  dataChannel: RTCDataChannel\n) {\n  return setupMessageDataChannel(connection, dataChannel)(\n    messagesToLobby,\n    messagesToPlayer\n  );\n}\n\nfunction setupMessageDataChannel(\n  connection: RTCPeerConnection,\n  dataChannel: RTCDataChannel\n) {\n  return setupMessageChannel({\n    send: (msg) => dataChannel.readyState === \"open\" && dataChannel.send(msg),\n    bindReceive(receive) {\n      dataChannel.addEventListener(\"message\", (ev) => receive(ev.data));\n      return () => {\n        dataChannel.close();\n        connection.close();\n      };\n    },\n  });\n}\n","import { useRef, useState, useEffect, useMemo } from \"react\";\n\nexport default function useJsonWebsocket(url?: string, reconnectAttempts = 5) {\n  const [retries, setRetries] = useState(0);\n  const failedAllRetries = retries > reconnectAttempts;\n  const [socket, setSocket] = useState<WebSocket>();\n  //Clear socket on url changes\n  useEffect(() => {\n    setSocket((socket) => {\n      if (socket) {\n        socket.onclose = null;\n        socket?.close();\n      }\n      return undefined;\n    });\n    setRetries(0);\n  }, [url]);\n  useEffect(() => {\n    if (!url || socket != null || failedAllRetries) {\n      return;\n    }\n    const s = new WebSocket(url);\n    let retryTimeout: number;\n    s.onclose = () => {\n      retryTimeout = window.setTimeout(() => {\n        setRetries((r) => r + 1);\n        setSocket(undefined);\n      }, 1000);\n    };\n    s.onopen = () => {\n      setSocket(s);\n      setRetries(0);\n    };\n    s.onerror = () => s.close();\n    return () => {\n      window.clearTimeout(retryTimeout);\n    };\n  }, [url, retries, socket]);\n  const jsonSocket = useMemo(\n    () =>\n      socket\n        ? {\n            addListener(listener: (data: any) => void) {\n              const fn = ({ data }: MessageEvent<any>) =>\n                listener(JSON.parse(data));\n              socket.addEventListener(\"message\", fn);\n              return () => socket.removeEventListener(\"message\", fn);\n            },\n            send(data: any) {\n              socket.send(JSON.stringify(data));\n            },\n          }\n        : null,\n    [socket]\n  );\n  return jsonSocket == null\n    ? {\n        status: failedAllRetries\n          ? (\"failed\" as const)\n          : (\"connecting\" as const),\n      }\n    : { status: \"connected\" as const, ...jsonSocket };\n}\n","export const typedEntries = Object.entries as <T, TKey extends keyof T>(\n  o: T\n) => [Extract<TKey, string>, T[TKey]][];\n\nexport const typedKeys = Object.keys as <T>(o: T) => (keyof T)[];\n\nexport function extractObjectDiff<T>(\n  source: T,\n  update: T,\n  ...omitTypes: string[]\n): Partial<T> {\n  return typedEntries(update ?? {})\n    .filter((entry) => !omitTypes.includes(typeof entry[1]))\n    .reduce((acc, [key, value]) => {\n      if (source?.[key] !== value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {} as Partial<T>);\n}\n\nexport function inlineThrow(err: string | Error): never {\n  throw typeof err === \"string\" ? new Error(err) : err;\n}\n\n//https://gist.github.com/LeverOne/1308368\nexport function uuidV4() {\n  let result = \"\";\n  for (\n    let step = 0;\n    step++ < 36;\n    result +=\n      (step * 51) & 52\n        ? (step ^ 15 ? 8 ^ (Math.random() * (step ^ 20 ? 16 : 4)) : 4).toString(\n            16\n          )\n        : \"-\"\n  );\n  return result;\n}\n\nexport function match<TMatch extends keyof any, TResult>(\n  value: TMatch,\n  output: Record<TMatch, TResult>\n){\n  return output[value];\n}\n"],"names":["SIGNALING_URL","DEFAULT_COLOR","DEFAULT_FONT_FAMILY","ALL_COLORS","DEFAULT_RTC_PEER_CONFIG","jsonConverter","numberConverter","booleanConverter","passValueConverter","input","result","stringConverter","setupMessageChannel","channelHooks","send","receive","bounce","bounceSet","listeners","unbind","indexOfMessageSeparator","messageType","messageListeners","messageData","_a","listener","type","data","extraParams","message","fn","fnIndex","_b","messagesToPlayer","messagesToLobby","createMessageChannelToPlayer","connection","dataChannel","setupMessageDataChannel","createMessageChannelToLobby","msg","ev","useJsonWebsocket","url","reconnectAttempts","retries","setRetries","useState","failedAllRetries","socket","setSocket","useEffect","s","retryTimeout","r","jsonSocket","useMemo","typedEntries","extractObjectDiff","source","update","omitTypes","entry","acc","key","value","inlineThrow","err","uuidV4","step","match","output"],"mappings":"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"}