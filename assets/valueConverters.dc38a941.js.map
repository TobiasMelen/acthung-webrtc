{"version":3,"file":"valueConverters.dc38a941.js","sources":["../../src/messaging/setupMessageChannel.ts","../../src/utility.ts","../../src/messaging/valueConverters.ts"],"sourcesContent":["/**\n * While this looks a bit jacked, it is just pubsub bindable to arbitrary string event interface using typed, custom, serializing.\n * Used by RTCDataChannel connections and webworkers. Data format is \"MESSAGE_TYPE;MESSAGE_DATA_WITH_CONFIGURED_SERIALIZER\"\n * Why not use JSON like a normal person?\n * Earlier i just put everything from UDP/Worker-messaging into JSON, but the 1ms added here and there actually adds upp to quite a bit of CPU time\n * A lot of events (turns/pings) don't have associated data, parsing json just to read a \"type\" prop of result.\n * Looked into protobufs but it looked very cargo-culty to me and not really established in JS-land.\n */\n\nexport type Converter<TResult> = {\n  serialize(result: TResult): string | void;\n  deserialize(input?: string): TResult;\n};\n\nexport type ConverterCollection = Record<string, Converter<any>>;\n\ntype EventHooks<TExtraSendParams extends any[] = []> = {\n  send(input: string, ...params: TExtraSendParams): void;\n  bindReceive(receive: (input: string) => void): (() => void) | void;\n};\n\ntype ConverterType<\n  TConverter extends Converter<any>\n> = TConverter extends Converter<infer Result> ? Result : never;\n\nexport type MessageChannel<\n  TSend extends ConverterCollection,\n  TReceive extends ConverterCollection,\n  TExtraSendParams extends any[] = []\n> = {\n  send<TMessage extends keyof TSend>(\n    type: TMessage,\n    data: ConverterType<TSend[TMessage]>,\n    ...extraParams: TExtraSendParams\n  ): void;\n  on<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  off<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  destroy(): void;\n};\n\nexport type BindableMessageChannel = ReturnType<typeof setupMessageChannel>;\n\n//HoF just to cut down on TS generic bloat.\nexport default function setupMessageChannel<\n  TExtraSendParams extends any[] = []\n>(channelHooks: EventHooks<TExtraSendParams>) {\n  return <\n    TSend extends ConverterCollection,\n    TReceive extends ConverterCollection\n  >(\n    send: TSend,\n    receive: TReceive,\n    ...bounce: string[]\n  ): MessageChannel<TSend, TReceive, TExtraSendParams> => {\n    const bounceSet = new Set(bounce);\n    const listeners = new Map<keyof TReceive, Function[]>();\n    //bind a single event listener to \"outer event\" and filter on serialized message type.\n    const unbind = channelHooks.bindReceive((input) => {\n      if (typeof input !== \"string\") {\n        return;\n      }\n      const indexOfMessageSeparator = input.indexOf(\";\");\n      const messageType =\n        indexOfMessageSeparator && input.substring(0, indexOfMessageSeparator);\n      //No message type could be parsed, exit out\n      if (!messageType) {\n        return;\n      }\n      //if this is a configured bounce message, bounce it directly as it came.\n      if (bounceSet.has(messageType)) {\n        //@ts-ignore no params here\n        channelHooks.send(input);\n      }\n      //check if anyones is listening before parsing message data and invoking listeners.\n      const messageListeners = listeners.get(messageType);\n      if (messageListeners?.length) {\n        const messageData = receive[messageType]?.deserialize(\n          input.substring(indexOfMessageSeparator + 1)\n        );\n        messageListeners.forEach((listener) => listener(messageData));\n      }\n    });\n    return {\n      send(type, data, ...extraParams) {\n        const message = `${type};${send[type].serialize(data)}`;\n        channelHooks.send(message, ...extraParams);\n      },\n      on(type, fn) {\n        if (!listeners.has(type)) {\n          listeners.set(type, []);\n        }\n        listeners.get(type)?.push(fn);\n      },\n      off(type, fn) {\n        const fnIndex = listeners.get(type)?.indexOf(fn);\n        if (fnIndex != null && fnIndex != -1) {\n          listeners.get(type)?.splice(fnIndex, 1);\n        }\n      },\n      destroy: unbind ? unbind : () => {},\n    };\n  };\n}\n\n/**Create a passthrough bridge between two sets of channelhooks */\nexport function bridgeChannelHooks(\n  channelHooks1: EventHooks,\n  channelHooks2: EventHooks\n) {\n  const unbind1 = channelHooks1.bindReceive(channelHooks2.send);\n  const unbind2 = channelHooks2.bindReceive(channelHooks1.send);\n  return {\n    destroy() {\n      unbind1 && unbind1();\n      unbind2 && unbind2();\n    },\n  };\n}\n","export const typedEntries = Object.entries as <T, TKey extends keyof T>(\n  o: T\n) => [Extract<TKey, string>, T[TKey]][];\n\nexport const typedKeys = Object.keys as <T>(o: T) => (keyof T)[];\n\nexport function extractObjectDiff<T>(\n  source: T,\n  update: T,\n  ...omitTypes: string[]\n): Partial<T> {\n  return typedEntries(update ?? {})\n    .filter((entry) => !omitTypes.includes(typeof entry[1]))\n    .reduce((acc, [key, value]) => {\n      if (source?.[key] !== value) {\n        acc[key] = value;\n      }\n      return acc;\n    }, {} as Partial<T>);\n}\n\nexport function inlineThrow(err: string | Error): never {\n  throw typeof err === \"string\" ? new Error(err) : err;\n}\n\n//https://gist.github.com/LeverOne/1308368\nexport function uuidV4() {\n  let result = \"\";\n  for (\n    let step = 0;\n    step++ < 36;\n    result +=\n      (step * 51) & 52\n        ? (step ^ 15 ? 8 ^ (Math.random() * (step ^ 20 ? 16 : 4)) : 4).toString(\n            16\n          )\n        : \"-\"\n  );\n  return result;\n}\n\nexport function match<TMatch extends keyof any, TResult>(\n  value: TMatch,\n  output: Record<TMatch, TResult>\n){\n  return output[value];\n}\n","import { Converter } from \"./setupMessageChannel\";\n\nexport const jsonConverter: Converter<any> = {\n  serialize: JSON.stringify,\n  deserialize: JSON.parse\n};\n\nexport const numberConverter: Converter<number> = {\n  serialize: String,\n  deserialize: Number\n};\n\nexport const booleanConverter: Converter<boolean> = {\n  serialize: String,\n  deserialize: Boolean\n};\n\n//This should not be needed, but having a special case for no message conversion will make channel impl. even messier.\n//Bench before changing\nexport const passValueConverter = <T extends string | void>(): Converter<T> => ({\n  serialize: input => input,\n  deserialize: result => result as T\n});\n\nexport const stringConverter = passValueConverter<string>();\n\nexport const voidConverter = passValueConverter<void>();"],"names":["channelHooks","send","receive","bounce","bounceSet","Set","listeners","Map","unbind","bindReceive","input","indexOfMessageSeparator","indexOf","messageType","substring","has","messageListeners","get","length","messageData","deserialize","forEach","listener","[object Object]","type","data","extraParams","message","serialize","fn","set","push","fnIndex","splice","destroy","typedEntries","Object","entries","source","update","omitTypes","filter","entry","includes","reduce","acc","key","value","err","Error","result","step","Math","random","toString","output","jsonConverter","JSON","stringify","parse","numberConverter","String","Number","booleanConverter","Boolean","stringConverter"],"mappings":"WAmDEA,SACO,CAILC,EACAC,KACGC,WAEGC,EAAY,IAAIC,IAAIF,GACpBG,EAAY,IAAIC,IAEhBC,EAASR,EAAaS,aAAaC,aAClB,iBAAVA,eAGLC,EAA0BD,EAAME,QAAQ,KACxCC,EACJF,GAA2BD,EAAMI,UAAU,EAAGH,OAE3CE,SAIDT,EAAUW,IAAIF,MAEHZ,KAAKS,SAGdM,EAAmBV,EAAUW,IAAIJ,YACnCG,WAAkBE,OAAQ,OACtBC,EAAc,WAAQN,aAAcO,YACxCV,EAAMI,UAAUH,EAA0B,MAE3BU,SAASC,GAAaA,EAASH,eAG7C,CACLI,KAAKC,EAAMC,KAASC,SACZC,EAAU,GAAGH,KAAQvB,EAAKuB,GAAMI,UAAUH,OACnCxB,KAAK0B,KAAYD,IAEhCH,GAAGC,EAAMK,SACFvB,EAAUS,IAAIS,MACPM,IAAIN,EAAM,eAEZP,IAAIO,OAAOO,KAAKF,IAE5BN,IAAIC,EAAMK,iBACFG,EAAU,WAAUf,IAAIO,aAAOZ,QAAQiB,GAC9B,MAAXG,OAAmBA,eACXf,IAAIO,OAAOS,OAAOD,EAAS,KAGzCE,QAAS1B,GAAkB,iBCzGpB2B,EAAeC,OAAOC,mBAOjCC,EACAC,KACGC,UAEIL,QAAaI,IAAU,IAC3BE,QAAQC,IAAWF,EAAUG,gBAAgBD,EAAM,MACnDE,QAAO,CAACC,GAAMC,EAAKC,wBACLD,MAASC,MAChBD,GAAOC,GAENF,IACN,eAGqBG,QACL,iBAARA,EAAmB,IAAIC,MAAMD,GAAOA,mBAK7CE,EAAS,WAEPC,EAAO,EACXA,IAAS,GACTD,GACU,GAAPC,EAAa,IACF,KAAK,EAAKC,KAAKC,UAAmB,KAAK,GAAK,GAAM,GAAGC,SAC3D,IAEF,YAEDJ,aAIPH,EACAQ,UAEOA,EAAOR,SC3CHS,EAAgC,CAC3C5B,UAAW6B,KAAKC,UAChBtC,YAAaqC,KAAKE,OAGPC,EAAqC,CAChDhC,UAAWiC,OACXzC,YAAa0C,QAGFC,EAAuC,CAClDnC,UAAWiC,OACXzC,YAAa4C,SAUFC,GAJXrC,aAAoBlB,EACpBU,eAAuB8B"}