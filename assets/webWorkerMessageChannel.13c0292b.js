const e={serialize:JSON.stringify,deserialize:JSON.parse},n={serialize:String,deserialize:Number},s={serialize:String,deserialize:Boolean},i={serialize:e=>e,deserialize:e=>e};function t(e){return(n,s,...i)=>{const t=new Set(i),r=new Map,a=e.bindReceive((n=>{var i;if("string"!=typeof n)return;const a=n.indexOf(";"),o=a&&n.substring(0,a);if(!o)return;t.has(o)&&e.send(n);const l=r.get(o);if(null==l?void 0:l.length){const e=null==(i=s[o])?void 0:i.deserialize(n.substring(a+1));l.forEach((n=>n(e)))}}));return{send(s,i,...t){const r=`${s};${n[s].serialize(i)}`;e.send(r,...t)},on(e,n){var s;r.has(e)||r.set(e,[]),null==(s=r.get(e))||s.push(n)},off(e,n){var s,i;const t=null==(s=r.get(e))?void 0:s.indexOf(n);null!=t&&-1!=t&&(null==(i=r.get(e))||i.splice(t,1))},destroy:a||(()=>{})}}}const r=Object.entries;function a(e,n,...s){return r(null!=n?n:{}).filter((e=>!s.includes(typeof e[1]))).reduce(((n,[s,i])=>((null==e?void 0:e[s])!==i&&(n[s]=i),n)),{})}function o(e){throw"string"==typeof e?new Error(e):e}const l={canvasInfo:e,positionData:e},d={reportCollision:i};function u(e){return(n,s)=>t({send:e.postMessage.bind(e),bindReceive(n){const s=e=>n(e.data);return e.addEventListener("message",s),()=>e.removeEventListener("message",s)}})(n,s)}export{i as a,s as b,u as c,d,a as e,o as i,e as j,l as m,n,t as s};
