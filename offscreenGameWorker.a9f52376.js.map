{"version":3,"sources":["messaging/valueConverters.ts","messaging/setupMessageChannel.ts","messaging/canvasWorkerMessaging.ts","canvas/snakeGameContext.ts","canvas/offscreenGameWorker.ts"],"names":[],"mappings":"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","file":"offscreenGameWorker.a9f52376.js","sourceRoot":"../src","sourcesContent":["import { Converter } from \"./setupMessageChannel\";\n\nexport const jsonConverter: Converter<any> = {\n  serialize: JSON.stringify,\n  deserialize: JSON.parse\n};\n\nexport const numberConverter: Converter<number> = {\n  serialize: String,\n  deserialize: Number\n};\n\nexport const booleanConverter: Converter<boolean> = {\n  serialize: String,\n  deserialize: Boolean\n};\n\n//This should not be needed, but having a special case for no message conversion will make channel impl. even messier.\n//Bench before changing\nconst passValueConverter = <T extends string | void>(): Converter<T> => ({\n  serialize: input => input,\n  deserialize: result => result as T\n});\n\nexport const stringConverter = passValueConverter<string>();\n\nexport const voidConverter = passValueConverter<void>();","/**\n * While this looks a bit jacked, it is just pubsub bindable to arbitrary string event interface using typed, custom, serializing.\n * Used by RTCDataChannel connections and webworkers. Data format is \"MESSAGE_TYPE;MESSAGE_DATA_WITH_CONFIGURED_SERIALIZER\"\n * Why not use JSON like a normal person?\n * Earlier i just put everything from UDP/Worker-messaging into JSON, but the 1ms added here and there actually adds upp to quite a bit of CPU time\n * A lot of events (turns/pings) don't have associated data, parsing json just to read a \"type\" prop of result.\n * Looked into protobufs but it looked very cargo-culty to me and not really established in JS-land.\n */\n\nexport type Converter<TResult> = {\n  serialize(result: TResult): string | void;\n  deserialize(input?: string): TResult;\n};\n\nexport type ConverterCollection = Record<string, Converter<any>>;\n\ntype EventHooks<TExtraSendParams extends any[] = []> = {\n  send(input: string, ...params: TExtraSendParams): void;\n  triggerReceive(trigger: (input: string) => void): void;\n  destroy(): void;\n};\n\ntype ConverterType<\n  TConverter extends Converter<any>\n> = TConverter extends Converter<infer Result> ? Result : never;\n\nexport type MessageChannel<\n  TSend extends ConverterCollection,\n  TReceive extends ConverterCollection,\n  TExtraSendParams extends any[] = []\n> = {\n  send<TMessage extends keyof TSend>(\n    type: TMessage,\n    data: ConverterType<TSend[TMessage]>,\n    ...extraParams: TExtraSendParams\n  ): void;\n  on<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  off<TMessage extends keyof TReceive>(\n    type: TMessage,\n    fn: (data: ConverterType<TReceive[TMessage]>) => void\n  ): void;\n  destroy(): void;\n};\n\n//HoF just to cut down on TS generic bloat.\nexport default function setupMessageChannel<\n  TExtraSendParams extends any[] = []\n>(channelHooks: EventHooks<TExtraSendParams>) {\n  return <\n    TSend extends ConverterCollection,\n    TReceive extends ConverterCollection\n  >(\n    send: TSend,\n    receive: TReceive,\n    ...bounce: string[]\n  ): MessageChannel<TSend, TReceive, TExtraSendParams> => {\n    const bounceSet = new Set(bounce);\n    const listeners = new Map<keyof TReceive, Function[]>();\n    //bind a single event listener to \"outer event\" and filter on serialized message type.\n    channelHooks.triggerReceive((input) => {\n      if (typeof input !== \"string\") {\n        return;\n      }\n      const indexOfMessageSeparator = input.indexOf(\";\");\n      const messageType =\n        indexOfMessageSeparator && input.substring(0, indexOfMessageSeparator);\n      //No message type could be parsed, exit out\n      if (!messageType) {\n        return;\n      }\n      //if this is a configured bounce message, bounce it directly as it came.\n      if (bounceSet.has(messageType)) {\n        //@ts-ignore no params here\n        channelHooks.send(input);\n      }\n      //check if anyones is listening before parsing message data and invoking listeners.\n      const messageListeners = listeners.get(messageType);\n      if (messageListeners?.length) {\n        const messageData = receive[messageType]?.deserialize(\n          input.substring(indexOfMessageSeparator + 1)\n        );\n        messageListeners.forEach((listener) => listener(messageData));\n      }\n    });\n    return {\n      send(type, data, ...extraParams) {\n        const message = `${type};${send[type].serialize(data)}`;\n        channelHooks.send(message, ...extraParams);\n      },\n      on(type, fn) {\n        if (!listeners.has(type)) {\n          listeners.set(type, []);\n        }\n        listeners.get(type)?.push(fn);\n      },\n      off(type, fn) {\n        const fnIndex = listeners.get(type)?.indexOf(fn);\n        if (fnIndex != null && fnIndex != -1) {\n          listeners.get(type)?.splice(fnIndex, 1);\n        }\n      },\n      destroy: channelHooks.destroy,\n    };\n  };\n}\n","import {\n  jsonConverter,\n  voidConverter,\n  stringConverter,\n} from \"./valueConverters\";\nimport setupMessageChannel, { Converter } from \"./setupMessageChannel\";\n\nconst messagesToWorker = {\n  turn: {\n    serialize(value: { id: string; turn: number }) {\n      return `${value.id};${value.turn}`;\n    },\n    deserialize(value: string) {\n      const split = value.split(\";\");\n      return { id: split[0], turn: parseFloat(split[1]) };\n    },\n  },\n  run: voidConverter,\n  stop: voidConverter,\n  destroy: voidConverter,\n  inputSnakeData: jsonConverter as Converter<{ id: string; color: string }>,\n};\n\nconst messageFromWorker = {\n  snakeCollision: stringConverter,\n  canvasCreated: voidConverter,\n};\n\nfunction hijackWorker(worker: Worker | DedicatedWorkerGlobalScope) {\n  const workerOriginalHandler = worker.onmessage;\n  return setupMessageChannel({\n    send: worker.postMessage.bind(worker),\n    triggerReceive(trigger) {\n      worker.onmessage = (ev) => trigger(ev.data);\n    },\n    destroy() {\n      worker.onmessage = workerOriginalHandler;\n      // terminate();\n    },\n  });\n}\n\nexport function createChannelToWorker(\n  ...params: Parameters<typeof hijackWorker>\n) {\n  return hijackWorker(...params)(messagesToWorker, messageFromWorker);\n}\n\nexport function createChannelFromWorker(\n  ...params: Parameters<typeof hijackWorker>\n) {\n  return hijackWorker(...params)(messageFromWorker, messagesToWorker);\n}\n","export type SnakeInput = {\n  id: string;\n  color: string;\n  onCollision: () => void;\n};\n\nconst frameTimeSixtyFps = 1000 / 60;\n\nexport type GameInput = Parameters<typeof snakeGameContext>[1];\n\nexport default function snakeGameContext(\n  canvas: HTMLCanvasElement | OffscreenCanvas,\n  {\n    snakeSpeed = 3.3,\n    lineWidth = 8,\n    turnRadius = 0.05,\n    startPositionSpread = 0.5,\n    startingHoleChancePercantage = -5,\n    holeDuration = 10,\n    maxVerticalResolution = 1080,\n  } = {}\n) {\n  {\n    const context =\n      (canvas.getContext(\"2d\", {\n        desynchronized: true,\n        willReadFrequently: true,\n      }) as OffscreenCanvasRenderingContext2D) ??\n      (() => {\n        throw new Error(\"Could not get Snake canvas 2d context\");\n      })();\n    if (canvas.height > maxVerticalResolution) {\n      const scaleFactor = canvas.height / maxVerticalResolution;\n      context.scale(scaleFactor, scaleFactor);\n    }\n    // context.globalCompositeOperation = \"destination-over\";\n\n    const createNewSnake = (input: SnakeInput) => ({\n      ...input,\n      hasCollided: false,\n      turn: 0,\n      direction: Math.round(Math.random() * 360),\n      holeChance: startingHoleChancePercantage,\n      position: {\n        x:\n          (Math.random() + startPositionSpread) *\n          (context.canvas.width * startPositionSpread),\n        y:\n          (Math.random() + startPositionSpread) *\n          (context.canvas.height * startPositionSpread),\n      },\n      currentHoleSection: 0,\n      erasePos: null as null | { x: number; y: number },\n    });\n\n    const snakes: (ReturnType<typeof createNewSnake> & SnakeInput)[] = [];\n\n    //Create or update snake and return turntrigger\n    const inputSnakeData = (input: SnakeInput) => {\n      let snake = snakes.find((snake) => snake.id === input.id);\n      if(snake == null){\n        snake = createNewSnake(input);\n        snakes.push(snake);\n      }\n      return (turn: number) => {\n        snake!.turn = turn;\n      };\n    };\n\n    //function for colliding and drawing snake\n    function moveSnake(\n      snake: typeof snakes[0],\n      snakeSpeed: number,\n      turnAngle: number,\n      checkCollision = true\n    ) {\n      if (snake.hasCollided) {\n        return;\n      }\n      if (snake.currentHoleSection == 0) {\n        if (snake.holeChance > 0 && Math.random() * 100 < snake.holeChance) {\n          snake.currentHoleSection = holeDuration;\n          snake.holeChance = startingHoleChancePercantage;\n        } else {\n          snake.holeChance = snake.holeChance + 0.1;\n        }\n      }\n\n      const willCollide =\n        (checkCollision &&\n          (snake.position.x < 0 ||\n            snake.position.x > canvas.width ||\n            snake.position.y < 0 ||\n            snake.position.y > canvas.height)) ||\n        context.getImageData(\n          snake.position.x +\n            (snakeSpeed + lineWidth / 2) * Math.cos(snake.direction),\n          snake.position.y +\n            (snakeSpeed + lineWidth / 2) * Math.sin(snake.direction),\n          1,\n          1\n        ).data[3] !== 0;\n      if (willCollide) {\n        snake.hasCollided = true;\n        snake.onCollision();\n      }\n\n      if (snake.erasePos != null) {\n        context.beginPath();\n        context.lineCap = \"square\";\n        context.lineWidth = lineWidth + 3;\n        const prevCompOp = context.globalCompositeOperation;\n        context.globalCompositeOperation = \"destination-out\";\n        context.moveTo(snake.erasePos.x, snake.erasePos.y);\n        context.lineTo(snake.position.x, snake.position.y);\n        context.stroke();\n        context.closePath();\n        snake.erasePos = null;\n        context.globalCompositeOperation = prevCompOp;\n      }\n\n      if (snake.currentHoleSection > 0) {\n        snake.erasePos = { ...snake.position };\n        snake.currentHoleSection--;\n      }\n\n      context.beginPath();\n      context.lineCap = \"square\";\n      context.lineWidth = lineWidth;\n      context.strokeStyle = snake.color;\n      context.moveTo(snake.position.x, snake.position.y);\n      snake.direction += snake.turn * turnAngle;\n      snake.position.x += snakeSpeed * Math.cos(snake.direction);\n      snake.position.y += snakeSpeed * Math.sin(snake.direction);\n      context.lineTo(snake.position.x, snake.position.y);\n      context.stroke();\n      context.closePath();\n    }\n\n    let stopped = true;\n    function run() {\n      let checkCollision = true;\n      let timeStamp = performance.now();\n      function drawFrame(now: number) {\n        const frameTimeActual = now - timeStamp;\n        let frameTimeOffset = frameTimeActual / frameTimeSixtyFps;\n        //Don't skip too far if we're lagging.\n        frameTimeOffset = frameTimeOffset < 4 ? frameTimeOffset : 4;\n        const frameTimeSnakeSpeed = snakeSpeed * frameTimeOffset;\n        const frameTimeTurnRadius = turnRadius * frameTimeOffset;\n        timeStamp = now;\n        for (const snake of snakes) {\n          moveSnake(\n            snake,\n            frameTimeSnakeSpeed,\n            frameTimeTurnRadius,\n            checkCollision\n          );\n        }\n        checkCollision = !checkCollision;\n        !stopped && requestAnimationFrame(drawFrame);\n      }\n      if (stopped) {\n        stopped = false;\n        requestAnimationFrame(drawFrame);\n      }\n    }\n    function stop() {\n      stopped = true;\n    }\n\n    return {\n      run,\n      stop,\n      inputSnakeData,\n      destroy() {\n        stop();\n      },\n    };\n  }\n}\n","/// <reference lib=\"WebWorker\" />\nimport { createChannelFromWorker } from \"../messaging/canvasWorkerMessaging\";\nimport snakeGameContext from \"./snakeGameContext\";\n\nconst messageHandler = (worker: DedicatedWorkerGlobalScope) => (ev: MessageEvent) => {\n  if (ev.data instanceof OffscreenCanvas) {\n    const channel = createChannelFromWorker(\n      worker\n    );\n    const game = snakeGameContext(ev.data);\n    const turners = new Map<string, Function>();\n    channel.on(\"turn\", (data) => turners.get(data.id)?.(data.turn));\n    channel.on(\"inputSnakeData\", (data) =>\n      turners.set(\n        data.id,\n        game.inputSnakeData({\n          ...data,\n          onCollision: () => channel.send(\"snakeCollision\", data.id),\n        })\n      )\n    );\n    channel.on(\"run\", game.run);\n    channel.on(\"stop\", game.stop);\n    channel.on(\"destroy\", () => {\n      game.destroy();\n      onmessage = messageHandler(worker);\n    });\n    channel.send(\"canvasCreated\", undefined);\n  }\n};\n\nonmessage = messageHandler(self as DedicatedWorkerGlobalScope);\n"]}